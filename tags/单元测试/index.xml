<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>单元测试 on 清松小站</title><link>https://coderqs.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><description>Recent content in 单元测试 on 清松小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 11 Mar 2019 00:00:00 +0800</lastBuildDate><atom:link href="https://coderqs.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>单元测试规范</title><link>https://coderqs.github.io/2019/03/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="单元测试规范">单元测试规范&lt;/h1>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;h3 id="覆盖率">覆盖率&lt;/h3>
&lt;p>覆盖率是对自动化测试运行期间执行了多少代码产生的度量（100%覆盖意味着每一行代码都至少执行过）
不必追求100%的覆盖率，覆盖率在60%-80%是一个不错的范围，这个主要根据项目的情况来决定。&lt;/p>
&lt;h2 id="单元测试原则">单元测试原则&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>DAMP 和DRY 这是一种平衡，而不是矛盾&lt;/strong>&lt;br>
DAMP 和 DRY
并不矛盾，而是平衡了代码可维护性的两个不同方面。可维护的代码（易于更改的代码）是这里的最终目标。&lt;br>
&lt;strong>DAMP（描述性和有意义的短语）提高了代码的可读性。&lt;/strong>&lt;br>
要维护代码，首先需要了解代码。要理解它，你必须阅读它。考虑一下你花多少时间阅读代码。这是很多。
DAMP 通过减少阅读和理解代码所需的时间来提高可维护性。&lt;br>
&lt;strong>DRY（不要重复自己）促进代码的&lt;a class="link" href="https://www.artima.com/articles/orthogonality-and-the-dry-principle" target="_blank" rel="noopener"
>正交性&lt;/a>。&lt;/strong>&lt;br>
删除重复确保系统中的每个概念在代码中都有一个单一的权威表示。对单个业务概念的更改会导致对代码的一次更改。DRY
通过将更改（风险）隔离到系统中必须更改的那些部分来提高可维护性。&lt;br>
&lt;strong>那么，为什么重复在测试中更容易接受？&lt;/strong>&lt;br>
测试通常包含固有的重复，因为它们一遍又一遍地测试相同的东西，只是输入值或设置代码略有不同。但是，与生产代码不同的是，这种重复通常仅与单个测试夹具/文件中的场景隔离。因此，重复是最小的和明显的，这意味着它比其他类型的重复给项目带来的风险更小。&lt;br>
此外，删除这种重复会降低测试的可读性。以前在每个测试中重复的细节现在隐藏在一些新方法或类中。为了全面了解测试，您现在必须在精神上将所有这些部分重新组合在一起。&lt;br>
因此，由于测试代码重复通常带来的风险较小，并提高了可读性，因此很容易看出它是如何被认为是可以接受的。&lt;br>
原则上，在生产代码中使用 DRY，在测试代码中使用
DAMP。虽然两者同等重要，但只要稍加智慧，您就可以在对自己有利的情况下平衡。&lt;/p>
&lt;p>引用自：&lt;a class="link" href="https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests" target="_blank" rel="noopener"
>在谈论单元测试时，&amp;ldquo;DAMP not DRY&amp;quot;是什么意思？&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="单元测试的准则">单元测试的准则&lt;/h2>
&lt;ul>
&lt;li>单元测试应该是可靠的，否则不能保证测试结果可信;&lt;/li>
&lt;li>单元测试应该是可维护且易于阅读和理解的;&lt;/li>
&lt;li>单元测试的每一个测试单元只测试一个用例，这样便于维护;&lt;/li>
&lt;li>单元测试应该可以在任何机器上顺序运行，且不会相互影响，如果可以，希望也能不依赖环境因素或全局/外部状态;&lt;/li>
&lt;li>单元测试应该自动化;&lt;/li>
&lt;li>结合使用单元测试和集成测试;&lt;/li>
&lt;li>单元测试应在有组织的测试实践中执行;&lt;/li>
&lt;/ul>
&lt;h2 id="单元测试用例的命名方法">单元测试用例的命名方法&lt;/h2>
&lt;p>这里提供以下七种命名方法以供参考&lt;/p>
&lt;h3 id="methodname_stateundertest_expectedbehavior方法名_在测试状态_预期行为">MethodName_StateUnderTest_ExpectedBehavior(方法名_在测试状态_预期行为)&lt;/h3>
&lt;p>如果方法名在重构的时候被更改，那么测试用例也应该同样被更改，否则以后会难以被理解。示例：&lt;br>
&lt;code>isAdult_AgeLessThan18_False&lt;/code>&lt;br>
&lt;code>withdrawMoney_InvalidAccount_ExceptionThrown&lt;/code>&lt;br>
&lt;code>admitStudent_MissingMandatoryFields_FailToAdmit&lt;/code>&lt;/p>
&lt;h3 id="methodname_expectedbehavior_stateundertest方法名_预期行为_在测试状态">MethodName_ExpectedBehavior_StateUnderTest(方法名_预期行为_在测试状态)&lt;/h3>
&lt;p>与第一种有相同的问题。示例：&lt;br>
&lt;code>isAdult_False_AgeLessThan18&lt;/code>&lt;br>
&lt;code>withdrawMoney_ThrowsException_IfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>admitStudent_FailToAdmit_IfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="testfeature-being-testedtest要测试的功能">test[Feature being tested](test要测试的功能)&lt;/h3>
&lt;p>将要测试的功能作为测试名称，增加了可读性。示例：&lt;br>
&lt;code>testIsNotAnAdultIfAgeLessThan18&lt;/code>&lt;br>
&lt;code>testFailToWithdrawMoneyIfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>testStudentIsNotAdmittedIfMandatoryFieldsAreMissing&lt;/code>&lt;br>
也可以选择去掉前缀test。示例：&lt;br>
&lt;code>IsNotAnAdultIfAgeLessThan18&lt;/code>&lt;br>
&lt;code>FailToWithdrawMoneyIfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>StudentIsNotAdmittedIfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="should_expectedbehavior_when_stateundertestshould_预期行为_when_在测试状态">Should_ExpectedBehavior_When_StateUnderTest(Should_预期行为_When_在测试状态)&lt;/h3>
&lt;p>&lt;code>Should_ThrowException_When_AgeLessThan18&lt;/code>&lt;br>
&lt;code>Should_FailToWithdrawMoney_ForInvalidAccount&lt;/code>&lt;br>
&lt;code>Should_FailToAdmit_IfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="when_stateundertest_expect_expectedbehaviorwhen_在测试状态_expect_预期行为">When_StateUnderTest_Expect_ExpectedBehavior(When_在测试状态_Expect_预期行为)&lt;/h3>
&lt;p>&lt;code>When_AgeLessThan18_Expect_isAdultAsFalse&lt;/code>&lt;br>
&lt;code>When_InvalidAccount_Expect_WithdrawMoneyToFail&lt;/code>&lt;br>
&lt;code>When_MandatoryFieldsAreMissing_Expect_StudentAdmissionToFail&lt;/code>&lt;/p>
&lt;h3 id="given_preconditions_when_stateundertest_then_expectedbehaviorgiven_先决条件_when_在测试状态_expect_预期行为">Given_Preconditions_When_StateUnderTest_Then_ExpectedBehavior(Given_先决条件_When_在测试状态_Expect_预期行为)&lt;/h3>
&lt;p>此方法基于作为行为驱动开发（BDD）一部分开发的命名约定。想法是将测试分为三部分，以便可以提出先决条件，测试状态和预期行为，并以上述格式编写。示例：&lt;br>
&lt;code>Given_UserIsAuthenticated_When_InvalidAccountNumberIsUsedToWithdrawMoney_Then_TransactionsWillFail&lt;/code>&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a class="link" href="https://testing.googleblog.com/" target="_blank" rel="noopener"
>在马桶上测试：测试过干吗？让他们成为DAMP！&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/unit-testing-best-practices-how-to-get-the-most-ou" target="_blank" rel="noopener"
>单元测试最佳实践：如何最大程度地利用测试自动化&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/7-popular-unit-test-naming" target="_blank" rel="noopener"
>7种流行的单元测试命名约定&lt;/a>&lt;br>
&lt;a class="link" href="http://cantgrokwontgrok.blogspot.com/2008/09/tdd-getting-started-with-test-driven.html" target="_blank" rel="noopener"
>TDD–测试驱动开发入门&lt;/a>&lt;br>
&lt;a class="link" href="https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html" target="_blank" rel="noopener"
>单元测试的命名标准&lt;/a>&lt;/p></description></item></channel></rss>