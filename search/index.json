[{"content":"Jsoncpp 使用方法 jsoncpp Github\n示例 以这个 json 串为例\n1 2 3 4 5 6 7 8 9 { \u0026#34;item_0\u0026#34;:\u0026#34;一个普通的 json 元素\u0026#34;, \u0026#34;arrary\u0026#34;:[\u0026#34;数组元素1\u0026#34;, \u0026#34;数组元素1\u0026#34;], \u0026#34;empty_arrary\u0026#34;:[], \u0026#34;item_1\u0026#34;:{ \u0026#34;item_item_0\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;item_item_1\u0026#34;:\u0026#34;\u0026#34; } } 使用在线工具检查 json 字符串是否合法，以及格式化、压缩转义等。\n解析 json 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 int ParseJson(std::string json_str) { Json::Reader reader; Json::Value root; try { if (reader.parse(json_str, root)) { if (root.isMember(\u0026#34;item_0\u0026#34;)) std::cout \u0026lt;\u0026lt; root[\u0026#34;item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; if (root.isMember(\u0026#34;array\u0026#34;)) { Json::Value val; val = root[\u0026#34;array\u0026#34;]; for (int i = 0; i \u0026lt; val.size(); ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl; } if (root.isMember(\u0026#34;empty_array\u0026#34;)) { Json::Value val; val = root[\u0026#34;empty_array\u0026#34;]; for (int i = 0; i \u0026lt; val.size(); ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;empty_array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;empty_array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl; } if (root.isMember(\u0026#34;item_1\u0026#34;)) { Json::Value val; val = root[\u0026#34;item_1\u0026#34;]; if (val.isMember(\u0026#34;item_item_0\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_0 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; } if (val.isMember(\u0026#34;item_item_1\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_1 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_1\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; } } } } catch (...) { std::cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 转为 json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int GenerateJson(Json::Value\u0026amp; root) { std::string str = \u0026#34;一个普通的 json 元素\u0026#34;; root[\u0026#34;item_0\u0026#34;] = str.c_str(); Json::Value val; for (int i = 0; i \u0026lt; 3; ++i) { val.append(\u0026#34;数组元素1\u0026#34;); } root[\u0026#34;array\u0026#34;] = val; root[\u0026#34;empty_array\u0026#34;] = Json::arrayValue; Json::Value item; item[\u0026#34;item_item_0\u0026#34;] = \u0026#34;item_item_0\u0026#34;; item[\u0026#34;item_item_1\u0026#34;] = \u0026#34;item_item_1\u0026#34;; root[\u0026#34;item_1\u0026#34;] = item; Json::FastWriter json_fw; std::cout \u0026lt;\u0026lt; \u0026#34;无格式的 Json: \u0026#34; \u0026lt;\u0026lt; json_fw.write(root) \u0026lt;\u0026lt; std::endl; Json::StyledWriter json_sw; std::cout \u0026lt;\u0026lt; \u0026#34;有格式的 Json: \u0026#34; \u0026lt;\u0026lt; json_sw.write(root) \u0026lt;\u0026lt; std::endl; return 0; } 其他接口 接口的详细介绍可以参考 jsoncpp 官方文档\n类型判断 isNull: 是否为空\nisBool: 是否为布尔值\nisInt: 是否为 int\nisArray: 是否为数组\nisMember: 是否存在该项\nisValidIndex:\n类型转换 asInt\nasString\n\u0026hellip;\n节点获取 get\n[]\n节点操作 compare\nswap\nremoveMember\nremoveindex\nappend\n完整示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;json/json.h\u0026#34; const char* kJsonStr = \u0026#34;{\u0026#34; \u0026#34;\\\u0026#34;item_0\\\u0026#34;:\\\u0026#34;一个普通的 json 元素\\\u0026#34;,\u0026#34; \u0026#34;\\\u0026#34;array\\\u0026#34;:[\\\u0026#34;数组元素0\\\u0026#34;, \\\u0026#34;数组元素1\\\u0026#34;],\u0026#34; \u0026#34;\\\u0026#34;empty_array\\\u0026#34;:[],\u0026#34; \u0026#34;\\\u0026#34;item_1\\\u0026#34;:{\u0026#34; \u0026#34;\\\u0026#34;item_item_0\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\u0026#34; \u0026#34;\\\u0026#34;item_item_1\\\u0026#34;:\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34; }\u0026#34; \u0026#34;}\u0026#34;; Json::Value ParseJson(std::string json_str) { Json::Reader reader; Json::Value root; try { if (reader.parse(json_str, root)) { if (root.isMember(\u0026#34;item_0\u0026#34;)) std::cout \u0026lt;\u0026lt; root[\u0026#34;item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; if (root.isMember(\u0026#34;array\u0026#34;)) { Json::Value val; val = root[\u0026#34;array\u0026#34;]; for (int i = 0; i \u0026lt; val.size(); ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl; } if (root.isMember(\u0026#34;empty_array\u0026#34;)) { Json::Value val; val = root[\u0026#34;empty_array\u0026#34;]; for (int i = 0; i \u0026lt; val.size(); ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;empty_array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;empty_array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl; } if (root.isMember(\u0026#34;item_1\u0026#34;)) { Json::Value val; val = root[\u0026#34;item_1\u0026#34;]; if (val.isMember(\u0026#34;item_item_0\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_0 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; } if (val.isMember(\u0026#34;item_item_1\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_1 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_1\u0026#34;].asString() \u0026lt;\u0026lt; std::endl; } } } } catch (...) { std::cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; std::endl; } return root; } int GenerateJson(Json::Value\u0026amp; root, std::string\u0026amp; not_format_json, std::string\u0026amp; format_json) { std::string str = \u0026#34;一个普通的 json 元素\u0026#34;; root[\u0026#34;item_0\u0026#34;] = str.c_str(); Json::Value val; for (int i = 0; i \u0026lt; 3; ++i) { val.append(\u0026#34;数组元素1\u0026#34;); } root[\u0026#34;array\u0026#34;] = val; root[\u0026#34;empty_array\u0026#34;] = Json::arrayValue; Json::Value item; item[\u0026#34;item_item_0\u0026#34;] = \u0026#34;item_item_0\u0026#34;; item[\u0026#34;item_item_1\u0026#34;] = \u0026#34;item_item_1\u0026#34;; root[\u0026#34;item_1\u0026#34;] = item; Json::FastWriter json_fw; not_format_json = json_fw.write(root); Json::StyledWriter json_sw; format_json = json_sw.write(root); return 0; } int main(int argc, char** argv) { std::cout \u0026lt;\u0026lt; \u0026#34;原始数据：\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; kJsonStr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;开始解析 json\u0026#34; \u0026lt;\u0026lt; std::endl; Json::Value root = ParseJson(kJsonStr); std::cout \u0026lt;\u0026lt; \u0026#34;json 解析完毕\u0026#34; \u0026lt;\u0026lt; std::endl; std::string not_format_json, format_json; GenerateJson(root, not_format_json, format_json); std::cout \u0026lt;\u0026lt; \u0026#34;无格式的 Json: \u0026#34; \u0026lt;\u0026lt; not_format_json \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;有格式的 Json: \u0026#34; \u0026lt;\u0026lt; format_json \u0026lt;\u0026lt; std::endl; return 0; } 参考资料 JsonCpp使用方法详解\n使用 jsoncpp 创建空的 json数组\nC++通过jsoncpp类库读写JSON文件\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderqs.github.io/1/01/","title":""},{"content":"使用 Cloudflare 后网站无限 301 跳转 原因分析 出现这个故障的大部分服务器都是因为服务器端使用了强制 HTTPS，而 CloudFlare 的 Flexible 策略原理是：用户访问时使用 HTTPS 访问到 CF 的节点，然后 CF通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF 就是访客，所以服务器返回的状态都是 301。\n解决方法 将 CloudFlare 的 SSL 策略设为 Full 或者 Full(strict) 就能解决。\n扩展 CloudFlare 的 SSL 可选模式 Off：关闭SSL，全程使用 HTTP； Flexible：A 使用 HTTPS，B 使用 HTTP，称为灵活加密； Full：AB全程使用 HTTPS，允许 B 程服务端使用自签名证书； Full(strict)：全程使用 HTTPS，与 Full 的区别在于服务端必须使用有效的可信任证书； 参考资料 CDN访问异常篇之重定向的次数过多\nCloudflare开启HTTPS/SSL后无限301跳转的解决方法\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderqs.github.io/1/01/%E4%BD%BF%E7%94%A8-cloudflare-%E5%90%8E%E7%BD%91%E7%AB%99%E6%97%A0%E9%99%90-301-%E8%B7%B3%E8%BD%AC/","title":"使用 Cloudflare 后网站无限 301 跳转"}]