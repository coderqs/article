<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>规范 on 清松小站</title><link>https://coderqs.github.io/tags/%E8%A7%84%E8%8C%83/</link><description>Recent content in 规范 on 清松小站</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 11 Mar 2019 00:00:00 +0800</lastBuildDate><atom:link href="https://coderqs.github.io/tags/%E8%A7%84%E8%8C%83/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 编码风格</title><link>https://coderqs.github.io/2019/03/c-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/c-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid><description>&lt;h1 id="c-编码风格">C++ 编码风格&lt;/h1>
&lt;p>这是基于 Google 发布的 C++
编程风格指南整理的，每一项规则的详细的阐述可以参见&lt;a class="link" href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener"
>官方的原版指南&lt;/a>或者&lt;a class="link" href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-cpp-styleguide/index.html" target="_blank" rel="noopener"
>中文版&lt;/a>。&lt;br>
&lt;strong>注意：这份指南只是提供了一份通用的编程规范，当你的项目已有自己的约定则优先遵守项目的约定！&lt;/strong>&lt;/p>
&lt;h2 id="头文件">头文件&lt;/h2>
&lt;p>通常一个一个 &lt;code>.cc&lt;/code> 对应一个
&lt;code>.h&lt;/code>，但也有一些常见的例外，例如单元测试代码只有 &lt;code>.cc&lt;/code> 文件和 &lt;code>main()&lt;/code>
函数。&lt;/p>
&lt;h3 id="self-contained-头文件">Self-contained 头文件&lt;/h3>
&lt;ol>
&lt;li>头文件，以 &lt;code>.h&lt;/code> 结尾;
&lt;ul>
&lt;li>用于插入文本的文件，以 &lt;code>.inc&lt;/code> 结尾;&lt;/li>
&lt;li>模板或内联函数的定义不要放到 &lt;code>-inl.h&lt;/code> 文件中;&lt;/li>
&lt;li>不建议从 &lt;code>.h&lt;/code> 中分离出 &lt;code>-inl.h&lt;/code> 文件;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="define-保护">#define 保护&lt;/h3>
&lt;p>所有头文件都应该使用 &lt;code>#define&lt;/code> 来防止头文件被多重包含, 命名格式当是:
&lt;code>&amp;lt;PROJECT&amp;gt;_&amp;lt;PATH&amp;gt;_&amp;lt;FILE&amp;gt;_H_&lt;/code>（路径是从项目的源代码树的根路径开始）。&lt;/p>
&lt;h3 id="前置声明">前置声明&lt;/h3>
&lt;p>尽可能地避免使用前置声明。使用 &lt;code>#include&lt;/code> 包含需要的头文件即可。&lt;/p>
&lt;ol>
&lt;li>尽量避免前置声明那些定义在其他项目中的实体;
&lt;ul>
&lt;li>函数：总是使用 &lt;code>#include&lt;/code>;&lt;/li>
&lt;li>类模板：优先使用 &lt;code>#include&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="内联函数">内联函数&lt;/h3>
&lt;ol>
&lt;li>不要内联超过 10 行的函数;
&lt;ul>
&lt;li>不要内联包含循环或 &lt;code>switch&lt;/code> 语句的函数;&lt;/li>
&lt;li>虚函数和递归函数不应该声明成内联;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="include-的路径及顺序">#include 的路径及顺序&lt;/h3>
&lt;ol>
&lt;li>避免使用特殊的快捷目录 &lt;code>.&lt;/code> 和 &lt;code>..&lt;/code>;
&lt;ul>
&lt;li>项目内头文件应按照项目源代码目录树结构排列;&lt;/li>
&lt;li>头文件的包含顺序如下：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&lt;code>.cc&lt;/code> 文件对应的头文件（优先位置）&lt;/li>
&lt;li>C 系统文件&lt;/li>
&lt;li>C++ 系统文件&lt;/li>
&lt;li>第三方库 &lt;code>.h&lt;/code> 文件&lt;/li>
&lt;li>本项目内 &lt;code>.h&lt;/code> 文件&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>以空行分割以上不同类别的 &lt;code>#include&lt;/code> 语句&lt;/li>
&lt;li>&lt;strong>例外&lt;/strong>：平台特定代码需要进行条件编译，这些可以放到其他的
&lt;code>#include&lt;/code> 之后&lt;/li>
&lt;/ol>
&lt;h2 id="作用域">作用域&lt;/h2>
&lt;h3 id="命名空间">命名空间&lt;/h3>
&lt;ol>
&lt;li>命名空间的最后(右括号)注释出名字空间的名字;
&lt;ul>
&lt;li>不要在命名空间 &lt;code>std&lt;/code> 内声明任何东西, 包括标准库的类前置声明;&lt;/li>
&lt;li>不要在头文件中使用&lt;strong>命名空间别名&lt;/strong>除非显式标记内部命名空间使用;&lt;/li>
&lt;li>禁止使用 &lt;code>using&lt;/code> 指令引入其他空间的符号;&lt;/li>
&lt;li>禁止使用内联命名空间;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="匿名命名空间和静态变量">匿名命名空间和静态变量&lt;/h3>
&lt;ol>
&lt;li>推荐、鼓励在 &lt;code>.cc&lt;/code>
中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在
&lt;code>.h&lt;/code> 中使用;
&lt;ul>
&lt;li>匿名命名空间的声明和具名的格式相同，在最后注释上 &lt;code>namespace&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="非成员函数静态成员函数和全局函数">非成员函数、静态成员函数和全局函数&lt;/h3>
&lt;ol>
&lt;li>
&lt;h2 id="尽量不要用裸的全局函数使用静态成员函数或命名空间内的非成员函数">尽量不要用裸的全局函数，使用静态成员函数或命名空间内的非成员函数;&lt;/h2>
将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果;
&lt;ul>
&lt;li>非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内;&lt;/li>
&lt;li>相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类,
不如使用&lt;a class="link" href="###%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" >命名空间&lt;/a>;&lt;/li>
&lt;li>如果必须定义非成员函数, 又只是在 &lt;code>.cc&lt;/code> 文件中使用它,
可使用&lt;a class="link" href="###%e5%8c%bf%e5%90%8d%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e5%92%8c%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f" >匿名命名空间&lt;/a> 或 &lt;code>static&lt;/code>
链接关键字(如 &lt;code>static int Foo() {...}&lt;/code>)限定其作用域;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="局部变量">局部变量&lt;/h3>
&lt;ol>
&lt;li>在尽可能小的作用域中声明变量, 离第一次使用越近越好;
&lt;ul>
&lt;li>使用初始化的方式替代声明再赋值，例如：&lt;code>int j = g();&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="静态和全局变量">静态和全局变量&lt;/h3>
&lt;ol>
&lt;li>禁止使用类的
&lt;a class="link" href="https://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F" target="_blank" rel="noopener"
>静态储存周期&lt;/a>
变量，不过 &lt;code>constexpr&lt;/code> 变量除外;
&lt;ul>
&lt;li>全局变量，静态变量，静态类成员变量和函数静态变量，都必须是 POD
(原生数据类型)以及 POD 类型的指针、数组和结构体;&lt;/li>
&lt;li>不允许用函数返回值来初始化 POD 变量，除非该函数（比如 &amp;lsquo;&amp;lsquo;getenv()&amp;rsquo;
或 &amp;lsquo;&amp;lsquo;getpid()&amp;rsquo; ）不涉及任何全局变量;&lt;/li>
&lt;li>多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL
容器);&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="类">类&lt;/h2>
&lt;h3 id="构造函数的职责">构造函数的职责&lt;/h3>
&lt;ol>
&lt;li>不要在构造中调用虚函数;
&lt;ul>
&lt;li>不要在无法报出错误时进行可能失败的初始化;&lt;/li>
&lt;li>如果对象需要正确的初始化，可以考虑使用明确的 &lt;code>Init()&lt;/code>
方法或者工厂模式;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="隐式类型转换">隐式类型转换&lt;/h3>
&lt;ol>
&lt;li>类型转换运算符和单参数构造函数都应当用 &lt;code>explicit&lt;/code> 进行标记;
&lt;ul>
&lt;li>拷贝和移动构造函数是个例外, &lt;strong>不应当被标记为&lt;/strong> &lt;code>explicit&lt;/code>;&lt;/li>
&lt;li>不能以一个参数进行调用的构造函数&lt;strong>不应当加上&lt;/strong> &lt;code>explicit&lt;/code>;&lt;/li>
&lt;li>接受一个 &lt;code>std::initializer_list&lt;/code> 作为参数的构造函数&lt;strong>也应当省略&lt;/strong>
&lt;code>explicit&lt;/code>, 以便支持拷贝初始化;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="可拷贝类型和可移动类型">可拷贝类型和可移动类型&lt;/h3>
&lt;ol>
&lt;li>
&lt;h2 id="如果类型的拷贝操作不是显而易见的就不要设置为可拷贝">如果类型的拷贝操作不是显而易见的，就不要设置为可拷贝;&lt;/h2>
如果类型可拷贝，那么一定要同时给出拷贝构造函数和赋值操作的定义，反之亦然;
&lt;ul>
&lt;li>如果让类型可拷贝, 同时移动操作的效率高于拷贝操作,
那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义;&lt;/li>
&lt;li>如果类型不可拷贝, 但是移动操作的正确性对用户显然可见,
那么把这个类型设置为只可移动并定义移动的两个操作;&lt;/li>
&lt;li>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的.
记得时刻检查默认操作的正确性,
并且在文档中说明类是可拷贝的且/或可移动的;&lt;/li>
&lt;li>不要为任何有可能有派生类的对象提供赋值操作或者拷贝/移动构造函数
(当然也不要继承有这样的成员函数的类);&lt;/li>
&lt;li>如果你的基类需要可复制属性, 请提供一个 public virtual Clone()
和一个 protected 的拷贝构造函数以供派生类实现;&lt;/li>
&lt;li>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 =
delete 或其他手段禁用;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="结构体-vs-类">结构体 VS 类&lt;/h3>
&lt;ol>
&lt;li>只有数据成员时使用 &lt;code>struct&lt;/code>:
&lt;ol>
&lt;li>用来定义包含数据的被动式对象, 也可以包含相关的常量,
但除了存取数据成员之外, 没有别的函数功能.
&lt;ul>
&lt;li>成员变量直接访问而不是函数调用.&lt;/li>
&lt;li>除了构造函数, 析构函数, &lt;code>Initialize()&lt;/code>, &lt;code>Reset()&lt;/code>,
&lt;code>Validate()&lt;/code> 等类似的用于设定数据成员的函数外,
不能提供其它功能的函数.&lt;/li>
&lt;li>如果需要更多的函数功能, &lt;code>class&lt;/code> 更适合. 如果拿不准, 就用
&lt;code>class&lt;/code>.&lt;/li>
&lt;li>除上述功能外其它的一概用 &lt;code>class&lt;/code>;&lt;/li>
&lt;li>为了和 STL 保持一致, 对于仿函数等特性可以不用 &lt;code>class&lt;/code> 而是使用
&lt;code>struct&lt;/code>;&lt;/li>
&lt;li>注意类和结构体的成员变量使用不同的&lt;a class="link" href="###%e5%8f%98%e9%87%8f%e5%91%bd%e5%90%8d" >命名规则&lt;/a>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="继承">继承&lt;/h3>
&lt;p>未完待续&lt;/p>
&lt;h2 id="函数">函数&lt;/h2>
&lt;h3 id="参数顺序">参数顺序&lt;/h3>
&lt;ol>
&lt;li>输入参数在前，输出参数在后;&lt;/li>
&lt;/ol>
&lt;h3 id="编写简短的函数">编写简短的函数&lt;/h3>
&lt;ol>
&lt;li>建议编写简短、凝练的函数（不硬性限制函数长度，但超过了 40
行，可以考虑下在&lt;strong>不影响程序结构&lt;/strong>的前提下对其分割）;&lt;/li>
&lt;/ol>
&lt;h3 id="引用参数">引用参数&lt;/h3>
&lt;ol>
&lt;li>输入参数是值参或 &lt;code>const&lt;/code> 引用, 输出参数为指针;&lt;/li>
&lt;/ol>
&lt;h3 id="函数重载">函数重载&lt;/h3>
&lt;ol>
&lt;li>如果打算重载一个函数，可以试试在函数名中加上参数信息，例如：用
&lt;code>AppendString()&lt;/code> 和 &lt;code>AppendInt()&lt;/code> 等，而不是重载多个 &lt;code>Append()&lt;/code>;
&lt;ul>
&lt;li>当重载函数是为了支持相同类型不同数量的参数时，则优先考虑使用
&lt;code>vector&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="缺省参数">缺省参数&lt;/h3>
&lt;ol>
&lt;li>
&lt;h2 id="虚函数不允许使用缺省参数">虚函数不允许使用缺省参数;&lt;/h2>
也不允许每次调用缺省参数的值都不同的情况下使用缺省参数，例如：&lt;code>void f(int n = counter+);&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="函数返回类型后置语法">函数返回类型后置语法&lt;/h3>
&lt;ol>
&lt;li>只有在常规写法不方便时使用，例如 Lambda 表达式;&lt;/li>
&lt;/ol>
&lt;h2 id="来自-google-的奇技">来自 Google 的奇技&lt;/h2>
&lt;h3 id="所有权与智能指针">所有权与智能指针&lt;/h3>
&lt;ol>
&lt;li>当你 new
了一块内存时尽量保证在释放前自已一直都持有这个内存的指针，当其他地方需要时传递过去指针或引用，再或者是使用
&lt;code>std::unique_ptr&lt;/code>;
&lt;ul>
&lt;li>尽量不要共享所有权，如果确实需要共享，建议使用
&lt;code>std::shared_ptr&lt;/code>;&lt;/li>
&lt;li>不要使用 &lt;code>std::auto_ptr&lt;/code>, 推荐使用 &lt;code>std::unique_ptr&lt;/code>;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="cpplint">Cpplint&lt;/h3>
&lt;ol>
&lt;li>&lt;code>cpplint.py&lt;/code> 是一个用来分析源文件, 能检查出多种风格错误的工具;
&lt;ul>
&lt;li>在行尾加 &lt;code>// NOLINT&lt;/code>, 或在上一行加 &lt;code>// NOLINTNEXTLINE&lt;/code>,
可以忽略报错;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="命名约定">命名约定&lt;/h2>
&lt;h3 id="通用命名规则">通用命名规则&lt;/h3>
&lt;ol>
&lt;li>尽可能使用描述性的命名，少用缩写（一些特定的广为人知的缩写是允许的，例如：用
&lt;code>i&lt;/code> 表示迭代变量和用 &lt;code>T&lt;/code> 表示模板参数）;
&lt;ul>
&lt;li>根据经验，如果在 Wikipedia 中列出了的缩写，则它可以考虑被使用;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="文件名">文件名&lt;/h3>
&lt;ol>
&lt;li>全部用小写，可以包含 &lt;code>_&lt;/code> 或 &lt;code>-&lt;/code>（更推荐 &lt;code>_&lt;/code>）;&lt;/li>
&lt;li>C++ 文件以 &lt;code>.cc&lt;/code> 结尾，头文件以 &lt;code>.h&lt;/code> 结尾，专门插入文本的文件以
&lt;code>.inc&lt;/code> 结尾;
&lt;ul>
&lt;li>不要使用与系统头文件相同的名字;&lt;/li>
&lt;li>尽量让文件名更加明确，不要太笼统（例如：使用 &lt;code>http_server_logs.h&lt;/code>
而不是 &lt;code>logs.h&lt;/code>）;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="类型命名">类型命名&lt;/h3>
&lt;ol>
&lt;li>类型名称的每个单词首字母均大写, 不包含下划线;&lt;/li>
&lt;/ol>
&lt;h3 id="变量命名">变量命名&lt;/h3>
&lt;ol>
&lt;li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接;
&lt;ul>
&lt;li>类的成员变量以下划线结尾, 但结构体的就不用;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="常量命名">常量命名&lt;/h3>
&lt;ol>
&lt;li>声明为 &lt;code>constexpr&lt;/code> 或 &lt;code>const&lt;/code> 的变量,
或在程序运行期间其值始终保持不变的, 命名时以 &lt;code>k&lt;/code> 开头, 大小写混合;&lt;/li>
&lt;/ol>
&lt;h3 id="函数命名">函数命名&lt;/h3>
&lt;ol>
&lt;li>函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”),
没有下划线;
&lt;ul>
&lt;li>缩写也是将其视为一个单词进行首字母大写，而不是全大写;&lt;/li>
&lt;li>取值和设值函数的命名与变量一致;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="名字空间命名">名字空间命名&lt;/h3>
&lt;ol>
&lt;li>命名空间以小写字母命名;
&lt;ul>
&lt;li>最高级命名空间的名字取决于项目名称;&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突;&lt;/li>
&lt;/ol>
&lt;h3 id="枚举命名">枚举命名&lt;/h3>
&lt;ol>
&lt;li>成员的命名与&lt;a class="link" href="###%e5%b8%b8%e9%87%8f%e5%91%bd%e5%90%8d" >常量&lt;/a>或者&lt;a class="link" href="###%e5%ae%8f%e5%91%bd%e5%90%8d" >宏&lt;/a>一致;
&lt;ul>
&lt;li>枚举类型的名字与&lt;a class="link" href="###%e5%87%bd%e6%95%b0%e5%91%bd%e5%90%8d" >函数命名&lt;/a>一致;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="宏命名">宏命名&lt;/h3>
&lt;ol>
&lt;li>不建议使用宏，但一定要用推荐使用全大写单词间以下划线分隔的方式来命名;&lt;/li>
&lt;/ol>
&lt;h3 id="命名规则的特例">命名规则的特例&lt;/h3>
&lt;ol>
&lt;li>如果你命名的实体与已有 C/C++ 实体相似,
可参考&lt;a class="link" href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-cpp-styleguide/naming.html#id15" target="_blank" rel="noopener"
>现有命名策略&lt;/a>;&lt;/li>
&lt;/ol>
&lt;h2 id="注释">注释&lt;/h2>
&lt;h3 id="注释风格">注释风格&lt;/h3>
&lt;ol>
&lt;li>使用 &lt;code>//&lt;/code> 或 &lt;code>/* */&lt;/code>, 统一就好. 但 &lt;code>//&lt;/code> 更常用.&lt;/li>
&lt;/ol>
&lt;h3 id="文件注释">文件注释&lt;/h3>
&lt;ol>
&lt;li>不要在 &lt;code>.h&lt;/code> 和 &lt;code>.cc&lt;/code> 之间复制注释, 保留一份即可.&lt;/li>
&lt;/ol>
&lt;h3 id="类注释">类注释&lt;/h3>
&lt;ol>
&lt;li>每个类的定义都要附带一份注释, 描述类的功能和用法,
除非它的功能相当明显.
&lt;ul>
&lt;li>描述类用法的注释应当和接口定义放在一起,
描述类的操作和实现的注释应当和实现放在一起.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="函数注释">函数注释&lt;/h3>
&lt;ol>
&lt;li>函数声明处的注释描述函数功能;
&lt;ul>
&lt;li>函数的输入输出.&lt;/li>
&lt;li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数,
是否会释放这些参数.&lt;/li>
&lt;li>函数是否分配了必须由调用者释放的空间.&lt;/li>
&lt;li>参数是否可以为空指针.&lt;/li>
&lt;li>是否存在函数使用上的性能隐患.&lt;/li>
&lt;li>如果函数是可重入的, 其同步前提是什么?&lt;/li>
&lt;li>定义处的注释描述函数实现.&lt;/li>
&lt;li>如果函数的实现过程中用到了很巧妙的方式,
那么在函数定义处应当加上解释性的注释, 例如, 使用的编程技巧,
实现的大致步骤, 或解释如此实现的理由.&lt;/li>
&lt;li>不要从 &lt;code>.h&lt;/code> 文件或其他地方的函数声明处直接复制注释,
简要重述函数功能是可以的, 但重点要放在如何实现上.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="变量注释">变量注释&lt;/h3>
&lt;ol>
&lt;li>当变量名和类型不能够用明确表达作用, 则应当加上注释(例如特殊值,
数据成员之间的关系, 生命周期等);
&lt;ul>
&lt;li>如果变量可以接受 &lt;code>NULL&lt;/code> 或 &lt;code>-1&lt;/code> 等警戒值, 须加以说明;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="实现注释">实现注释&lt;/h3>
&lt;ol>
&lt;li>巧妙或复杂的代码段前要加注释;
&lt;ul>
&lt;li>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释;&lt;/li>
&lt;li>对齐连续多行的注释;&lt;/li>
&lt;li>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:&lt;/li>
&lt;li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用,
用以推断它们一致, 你应当用一个常量名让这一约定变得更明显,
并且保证这一约定不会被打破.&lt;/li>
&lt;li>考虑更改函数的签名, 让某个 &lt;code>bool&lt;/code> 类型的参数变为 &lt;code>enum&lt;/code> 类型,
这样可以让这个参数的值表达其意义.&lt;/li>
&lt;li>如果某个函数有多个配置选项,
你可以考虑定义一个类或结构体以保存所有的选项,
并传入类或结构体的实例. 这样的方法有许多优点,
例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义.
同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外,
以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.&lt;/li>
&lt;li>用具名变量代替大段而复杂的嵌套表达式.&lt;/li>
&lt;li>万不得已时, 才考虑在调用点用注释阐明参数的意义.&lt;/li>
&lt;li>不要描述显而易见的现象;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="标点-拼写和语法">标点, 拼写和语法&lt;/h3>
&lt;ol>
&lt;li>注意标点, 拼写和语法;&lt;/li>
&lt;/ol>
&lt;h3 id="todo-注释">TODO 注释&lt;/h3>
&lt;ol>
&lt;li>&lt;code>TODO&lt;/code> 注释要使用全大写的字符串, 在随后的圆括号里写上你的名字,
邮件地址, bug ID 或其它身份标识和这一 &lt;code>TODO&lt;/code> 相关的 issue;
&lt;ul>
&lt;li>如果加 TODO 是为了在 “将来某一天做某事”,
可以附上一个非常明确的时间;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="弃用注释">弃用注释&lt;/h3>
&lt;ol>
&lt;li>可以写上包含全大写的 &lt;code>DEPRECATED&lt;/code> 的注释, 以标记某接口为弃用状态.
注释可以放在接口声明前, 或者同一行;
&lt;ul>
&lt;li>仅仅标记接口为 &lt;code>DEPRECATED&lt;/code> 并不会让大家不约而同地弃用,
您还得亲自主动修正调用点;&lt;br>
===== 格式 =====&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="行长度">行长度&lt;/h3>
&lt;ol>
&lt;li>每一行代码字符数不超过 80;
&lt;ul>
&lt;li>包含长路径的 &lt;code>#include&lt;/code> 语句可以超出80列;&lt;/li>
&lt;li>头文件卫士无视该原则;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="非-ascii-字符">非 ASCII 字符&lt;/h3>
&lt;ol>
&lt;li>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码;&lt;/li>
&lt;/ol>
&lt;h3 id="空格还是制表位">空格还是制表位&lt;/h3>
&lt;ol>
&lt;li>只使用空格, 每次缩进 2 个空格;
&lt;ul>
&lt;li>设置编辑器将制表符转为空格;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="函数声明与定义">函数声明与定义&lt;/h3>
&lt;ol>
&lt;li>返回类型和函数名在同一行;
&lt;ul>
&lt;li>参数尽量放在同一行, 如果放不下就对形参分行, 分行方式与
&lt;a class="link" href="###%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8" >函数调用&lt;/a> 一致;&lt;/li>
&lt;li>使用好的参数名.&lt;/li>
&lt;li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.&lt;/li>
&lt;li>如果返回类型和函数名在一行放不下, 分行.&lt;/li>
&lt;li>如果返回类型与函数声明或定义分行了, 不要缩进.&lt;/li>
&lt;li>左圆括号总是和函数名在同一行.&lt;/li>
&lt;li>函数名和左圆括号间永远没有空格.&lt;/li>
&lt;li>圆括号与参数间没有空格.&lt;/li>
&lt;li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.&lt;/li>
&lt;li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.&lt;/li>
&lt;li>右圆括号和左大括号间总是有一个空格.&lt;/li>
&lt;li>所有形参应尽可能对齐.&lt;/li>
&lt;li>缺省缩进为 2 个空格.&lt;/li>
&lt;li>换行后的参数保持 4 个空格的缩进.&lt;/li>
&lt;li>未被使用的参数如果其用途不明显的话,
在函数定义处将参数名注释起来;&lt;/li>
&lt;li>属性, 和展开为属性的宏, 写在函数声明或定义的最前面,
即返回类型之前;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="lambda-表达式">Lambda 表达式&lt;/h3>
&lt;ol>
&lt;li>对形参和函数体的格式化和其他函数一致; 捕获列表同理,
表项用逗号隔开;&lt;/li>
&lt;/ol>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;ol>
&lt;li>
&lt;h2 id="比如把多个参数适当地放在同一行里">要么一行写完函数调用, 要么在圆括号里对参数分行,
要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数,
比如把多个参数适当地放在同一行里;&lt;/h2>
如果参数本身是略复杂的表达式，且降低了可读性，那么可以直接创建临时变量描述该表达式并传递给函数;
&lt;ul>
&lt;li>如果参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="列表初始化格式">列表初始化格式&lt;/h3>
&lt;ol>
&lt;li>平时怎么格式化函数调用, 就怎么格式化&lt;a class="link" href="###%e5%88%97%e8%a1%a8%e5%88%9d%e5%a7%8b%e5%8c%96" >列表初始化&lt;/a>.&lt;/li>
&lt;/ol>
&lt;h3 id="条件语句">条件语句&lt;/h3>
&lt;ol>
&lt;li>关键字 &lt;code>if&lt;/code> 和 &lt;code>else&lt;/code> 另起一行, &lt;code>else&lt;/code> 与 &lt;code>if&lt;/code> 的 &lt;code>}&lt;/code> 同一行;
&lt;ul>
&lt;li>&lt;code>if&lt;/code> 和 &lt;code>(&lt;/code> 间都有个空格, &lt;code>)&lt;/code> 和 &lt;code>{&lt;/code> 之间也要有个空格;&lt;/li>
&lt;li>简短的条件语句允许写在同一行，当存在 &lt;code>else&lt;/code> 分支时则不允许;&lt;/li>
&lt;li>当语句中某个 &lt;code>if-else&lt;/code> 分支使用了大括号时, 其它分支也必须使用;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="循环和开关选择语句">循环和开关选择语句&lt;/h3>
&lt;ol>
&lt;li>&lt;code>switch&lt;/code> 应该总是包含一个 &lt;code>default&lt;/code> 匹配, 如果 &lt;code>default&lt;/code>
应该永远执行不到, 简单的加条 &lt;code>assert&lt;/code>;&lt;/li>
&lt;li>空循环体应使用 &lt;code>{}&lt;/code> 或 &lt;code>continue&lt;/code>, 而不是一个简单的分号;&lt;/li>
&lt;/ol>
&lt;h3 id="指针和引用表达式">指针和引用表达式&lt;/h3>
&lt;ol>
&lt;li>在访问成员时, 句点或箭头前后没有空格;
&lt;ul>
&lt;li>指针操作符 &lt;code>*&lt;/code> 或 &lt;code>&amp;amp;&lt;/code> 后没有空格;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="布尔表达式">布尔表达式&lt;/h3>
&lt;ol>
&lt;li>断行时逻辑操作符(&lt;code>&amp;amp;&amp;amp;&lt;/code>, &lt;code>||&lt;/code>)总位于行尾;&lt;/li>
&lt;/ol>
&lt;h3 id="函数返回值">函数返回值&lt;/h3>
&lt;ol>
&lt;li>不要在 &lt;code>return&lt;/code>
表达式里加上非必须的圆括号(类似&lt;code>return (value)&lt;/code>这种形式);
&lt;ul>
&lt;li>可以用圆括号把复杂表达式圈起来, 改善可读性;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="变量及数组初始化">变量及数组初始化&lt;/h3>
&lt;ol>
&lt;li>用 &lt;code>=&lt;/code>, &lt;code>()&lt;/code> 和 &lt;code>{}&lt;/code> 均可;
&lt;ul>
&lt;li>列表初始化(&lt;code>{}&lt;/code>)不允许整型类型的四舍五入;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="预处理指令">预处理指令&lt;/h3>
&lt;ol>
&lt;li>预处理指令不要缩进, 从行首开始, 即使位于缩进代码块中,
也应从行首开始;&lt;/li>
&lt;/ol>
&lt;h3 id="类格式">类格式&lt;/h3>
&lt;ol>
&lt;li>访问控制块的声明依次序是 &lt;code>public:&lt;/code>, &lt;code>protected:&lt;/code>, &lt;code>private:&lt;/code>,
每个都缩进 1 个空格;
&lt;ul>
&lt;li>所有基类名应在 80 列限制下尽量与子类名放在同一行;&lt;/li>
&lt;li>除第一个关键词 (一般是 public) 外,
其他关键词前要空一行,这些关键词后不要保留空行..
如果类比较小的话也可以不空&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="构造函数初始值列表">构造函数初始值列表&lt;/h3>
&lt;ol>
&lt;li>构造函数初始化列表放在同一行或按四格缩进并排多行;
&lt;ul>
&lt;li>如果不能放在同一行, 必须置于冒号后, 并缩进 4 个空格.&lt;/li>
&lt;li>如果初始化列表需要置于多行,
将每一个成员放在单独的一行并逐行对齐.&lt;/li>
&lt;li>&lt;code>}&lt;/code> 可以和 &lt;code>{&lt;/code> 放在同一行, 如果这样做合适的话.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="命名空间格式化">命名空间格式化&lt;/h3>
&lt;ol>
&lt;li>命名空间内容不要增加额外的缩进层次;
&lt;ul>
&lt;li>声明嵌套命名空间时, 每个命名空间都独立成行;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="水平留白">水平留白&lt;/h3>
&lt;h4 id="通用">通用&lt;/h4>
&lt;ol>
&lt;li>&lt;code>{&lt;/code> 前总是有空格.
&lt;ul>
&lt;li>&lt;code>;&lt;/code> 前不加空格.&lt;/li>
&lt;li>继承与初始化列表中的 &lt;code>:&lt;/code> 前后恒有空格.&lt;/li>
&lt;li>对于单行函数的实现, 在大括号内加上空格, 即
&lt;code>int fun(int v) { return v; }&lt;/code>.&lt;/li>
&lt;li>函数的 &lt;code>{}&lt;/code> 里面是空的话, 不加空格.&lt;/li>
&lt;li>&lt;code>(&lt;/code> 的后面和 &lt;code>)&lt;/code> 的前面都不加空格.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="循环和条件语句">循环和条件语句&lt;/h4>
&lt;ol>
&lt;li>&lt;code>if&lt;/code> 条件语句和循环语句关键字后均有空格.
&lt;ul>
&lt;li>&lt;code>else&lt;/code> 前后都有空格.&lt;/li>
&lt;li>&lt;code>for&lt;/code> 循环里 &lt;code>;&lt;/code> 后有空格.&lt;/li>
&lt;li>&lt;code>switch case&lt;/code> 的 &lt;code>:&lt;/code> 前无空格, 如果 &lt;code>:&lt;/code> 后面有代码, 则 &lt;code>:&lt;/code>
后面加个空格.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="操作符">操作符&lt;/h4>
&lt;ol>
&lt;li>赋值运算符前后总是有空格.
&lt;ul>
&lt;li>其它二元操作符也前后总有空格, 不过对于表达式的子式可以不加空格.&lt;/li>
&lt;li>在参数和一元操作符之间不加空格.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="模板和转换">模板和转换&lt;/h4>
&lt;ol>
&lt;li>&lt;code>&amp;lt; &amp;gt;&lt;/code>(尖括号) 不与空格紧邻, &lt;code>&amp;lt;&lt;/code> 前没有空格, &lt;code>&amp;gt;&lt;/code> 和 &lt;code>(&lt;/code> 之间也没有.&lt;/li>
&lt;/ol>
&lt;h3 id="垂直留白">垂直留白&lt;/h3>
&lt;ol>
&lt;li>两个函数定义之间的空行不要超过 2 行;
&lt;ul>
&lt;li>函数体首尾不要留空行;&lt;/li>
&lt;li>函数体中也不要随意添加空行;&lt;/li>
&lt;li>在多重 &lt;code>if-else&lt;/code> 块里加空行&lt;strong>或许&lt;/strong>有点可读性;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="规则特例">规则特例&lt;/h2>
&lt;h3 id="现有不合规范的代码">现有不合规范的代码&lt;/h3>
&lt;ol>
&lt;li>对于现有不符合既定编程风格的代码，优先与代码原有风格保持一致;&lt;/li>
&lt;/ol>
&lt;h3 id="windows-代码">Windows 代码&lt;/h3>
&lt;p>这一部分可以参考指南的原文档。&lt;/p>
&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;p>&lt;a class="link" href="https://google.github.io/styleguide/cppguide.html#Header_Files" target="_blank" rel="noopener"
>Google C++ Style
Guide&lt;/a>&lt;br>
&lt;a class="link" href="https://google-styleguide.readthedocs.io/zh_CN/latest/google-cpp-styleguide/scoping.html" target="_blank" rel="noopener"
>Google
开源项目风格指南(中文版)&lt;/a>&lt;/p></description></item><item><title>C++ 注释风格</title><link>https://coderqs.github.io/2019/03/c-%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/c-%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/</guid><description>&lt;h1 id="c-注释风格">C++ 注释风格&lt;/h1>
&lt;p>个人比较认同的三种注释风格&lt;/p>
&lt;h2 id="doxygen-风格">doxygen 风格&lt;/h2>
&lt;p>指的是 &lt;code>doxygen&lt;/code> 或者基于 &lt;code>doxygen&lt;/code> 语法的一些变体的注释。&lt;br>
这种注释好处是可以直接使用 &lt;code>doxygen&lt;/code> 的工具生成文档，但坏处就是太啰嗦，而且这种注释大家在修改代码的时候多数都懒得修改，容易造成注释与代码对不上的情况。&lt;/p>
&lt;h2 id="rustdoc-风格">rustdoc 风格&lt;/h2>
&lt;p>&lt;code>rustdoc&lt;/code> 所推荐的注释风格，直接在 &lt;code>///&lt;/code> 型的注释里使用 &lt;code>markdown&lt;/code> 语法写注释即可。&lt;br>
这种注释书写起来很方便，但需要了解 &lt;code>markdown&lt;/code> 的语法，对经常使用 &lt;code>markdown&lt;/code> 的人员来说非常直观。&lt;/p>
&lt;h2 id="简约风格">简约风格&lt;/h2>
&lt;p>这种风格提倡在代码中使用良好的命名使代码具有自解释性，以此来适当的减少描述性的注释出现，避免造成代码的不连续。&lt;br>
这种注释对于命名的能力有着较高要求，毕竟在开发过程中能起一个准确又合适的名字不是一件简单的事情，但是这种风格的代码在看的时候很舒服的。&lt;br>
使用这种风格有以下几个注意点与建议：&lt;/p>
&lt;ul>
&lt;li>规范、准确的命名。&lt;/li>
&lt;li>区分使用代码注释 &lt;code>/**/&lt;/code> (只注释代码) 与说明注释 &lt;code>///&lt;/code> ()&lt;/li>
&lt;li>可以借助第三方工具生成复杂化注释或者VS自带的snippet,支持自己编辑复杂注释(可以参考[VisualStudio自定义设置](/编程工具/IDE/VisualStudio/自定义设置#Doc Comment))。&lt;/li>
&lt;li>减少多行注释，允许的情况下与代码同行。&lt;/li>
&lt;li>多人协作最好在注释后加签名和时间，例如：&lt;code>/// Fix bug #12345 [coderqs@20200101]&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.zhihu.com/question/371144076" target="_blank" rel="noopener"
>C++注释规范是什么？&lt;/a>&lt;/p></description></item><item><title>单元测试规范</title><link>https://coderqs.github.io/2019/03/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</guid><description>&lt;h1 id="单元测试规范">单元测试规范&lt;/h1>
&lt;h2 id="名词解释">名词解释&lt;/h2>
&lt;h3 id="覆盖率">覆盖率&lt;/h3>
&lt;p>覆盖率是对自动化测试运行期间执行了多少代码产生的度量（100%覆盖意味着每一行代码都至少执行过）
不必追求100%的覆盖率，覆盖率在60%-80%是一个不错的范围，这个主要根据项目的情况来决定。&lt;/p>
&lt;h2 id="单元测试原则">单元测试原则&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>DAMP 和DRY 这是一种平衡，而不是矛盾&lt;/strong>&lt;br>
DAMP 和 DRY
并不矛盾，而是平衡了代码可维护性的两个不同方面。可维护的代码（易于更改的代码）是这里的最终目标。&lt;br>
&lt;strong>DAMP（描述性和有意义的短语）提高了代码的可读性。&lt;/strong>&lt;br>
要维护代码，首先需要了解代码。要理解它，你必须阅读它。考虑一下你花多少时间阅读代码。这是很多。
DAMP 通过减少阅读和理解代码所需的时间来提高可维护性。&lt;br>
&lt;strong>DRY（不要重复自己）促进代码的&lt;a class="link" href="https://www.artima.com/articles/orthogonality-and-the-dry-principle" target="_blank" rel="noopener"
>正交性&lt;/a>。&lt;/strong>&lt;br>
删除重复确保系统中的每个概念在代码中都有一个单一的权威表示。对单个业务概念的更改会导致对代码的一次更改。DRY
通过将更改（风险）隔离到系统中必须更改的那些部分来提高可维护性。&lt;br>
&lt;strong>那么，为什么重复在测试中更容易接受？&lt;/strong>&lt;br>
测试通常包含固有的重复，因为它们一遍又一遍地测试相同的东西，只是输入值或设置代码略有不同。但是，与生产代码不同的是，这种重复通常仅与单个测试夹具/文件中的场景隔离。因此，重复是最小的和明显的，这意味着它比其他类型的重复给项目带来的风险更小。&lt;br>
此外，删除这种重复会降低测试的可读性。以前在每个测试中重复的细节现在隐藏在一些新方法或类中。为了全面了解测试，您现在必须在精神上将所有这些部分重新组合在一起。&lt;br>
因此，由于测试代码重复通常带来的风险较小，并提高了可读性，因此很容易看出它是如何被认为是可以接受的。&lt;br>
原则上，在生产代码中使用 DRY，在测试代码中使用
DAMP。虽然两者同等重要，但只要稍加智慧，您就可以在对自己有利的情况下平衡。&lt;/p>
&lt;p>引用自：&lt;a class="link" href="https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests" target="_blank" rel="noopener"
>在谈论单元测试时，&amp;ldquo;DAMP not DRY&amp;quot;是什么意思？&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="单元测试的准则">单元测试的准则&lt;/h2>
&lt;ul>
&lt;li>单元测试应该是可靠的，否则不能保证测试结果可信;&lt;/li>
&lt;li>单元测试应该是可维护且易于阅读和理解的;&lt;/li>
&lt;li>单元测试的每一个测试单元只测试一个用例，这样便于维护;&lt;/li>
&lt;li>单元测试应该可以在任何机器上顺序运行，且不会相互影响，如果可以，希望也能不依赖环境因素或全局/外部状态;&lt;/li>
&lt;li>单元测试应该自动化;&lt;/li>
&lt;li>结合使用单元测试和集成测试;&lt;/li>
&lt;li>单元测试应在有组织的测试实践中执行;&lt;/li>
&lt;/ul>
&lt;h2 id="单元测试用例的命名方法">单元测试用例的命名方法&lt;/h2>
&lt;p>这里提供以下七种命名方法以供参考&lt;/p>
&lt;h3 id="methodname_stateundertest_expectedbehavior方法名_在测试状态_预期行为">MethodName_StateUnderTest_ExpectedBehavior(方法名_在测试状态_预期行为)&lt;/h3>
&lt;p>如果方法名在重构的时候被更改，那么测试用例也应该同样被更改，否则以后会难以被理解。示例：&lt;br>
&lt;code>isAdult_AgeLessThan18_False&lt;/code>&lt;br>
&lt;code>withdrawMoney_InvalidAccount_ExceptionThrown&lt;/code>&lt;br>
&lt;code>admitStudent_MissingMandatoryFields_FailToAdmit&lt;/code>&lt;/p>
&lt;h3 id="methodname_expectedbehavior_stateundertest方法名_预期行为_在测试状态">MethodName_ExpectedBehavior_StateUnderTest(方法名_预期行为_在测试状态)&lt;/h3>
&lt;p>与第一种有相同的问题。示例：&lt;br>
&lt;code>isAdult_False_AgeLessThan18&lt;/code>&lt;br>
&lt;code>withdrawMoney_ThrowsException_IfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>admitStudent_FailToAdmit_IfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="testfeature-being-testedtest要测试的功能">test[Feature being tested](test要测试的功能)&lt;/h3>
&lt;p>将要测试的功能作为测试名称，增加了可读性。示例：&lt;br>
&lt;code>testIsNotAnAdultIfAgeLessThan18&lt;/code>&lt;br>
&lt;code>testFailToWithdrawMoneyIfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>testStudentIsNotAdmittedIfMandatoryFieldsAreMissing&lt;/code>&lt;br>
也可以选择去掉前缀test。示例：&lt;br>
&lt;code>IsNotAnAdultIfAgeLessThan18&lt;/code>&lt;br>
&lt;code>FailToWithdrawMoneyIfAccountIsInvalid&lt;/code>&lt;br>
&lt;code>StudentIsNotAdmittedIfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="should_expectedbehavior_when_stateundertestshould_预期行为_when_在测试状态">Should_ExpectedBehavior_When_StateUnderTest(Should_预期行为_When_在测试状态)&lt;/h3>
&lt;p>&lt;code>Should_ThrowException_When_AgeLessThan18&lt;/code>&lt;br>
&lt;code>Should_FailToWithdrawMoney_ForInvalidAccount&lt;/code>&lt;br>
&lt;code>Should_FailToAdmit_IfMandatoryFieldsAreMissing&lt;/code>&lt;/p>
&lt;h3 id="when_stateundertest_expect_expectedbehaviorwhen_在测试状态_expect_预期行为">When_StateUnderTest_Expect_ExpectedBehavior(When_在测试状态_Expect_预期行为)&lt;/h3>
&lt;p>&lt;code>When_AgeLessThan18_Expect_isAdultAsFalse&lt;/code>&lt;br>
&lt;code>When_InvalidAccount_Expect_WithdrawMoneyToFail&lt;/code>&lt;br>
&lt;code>When_MandatoryFieldsAreMissing_Expect_StudentAdmissionToFail&lt;/code>&lt;/p>
&lt;h3 id="given_preconditions_when_stateundertest_then_expectedbehaviorgiven_先决条件_when_在测试状态_expect_预期行为">Given_Preconditions_When_StateUnderTest_Then_ExpectedBehavior(Given_先决条件_When_在测试状态_Expect_预期行为)&lt;/h3>
&lt;p>此方法基于作为行为驱动开发（BDD）一部分开发的命名约定。想法是将测试分为三部分，以便可以提出先决条件，测试状态和预期行为，并以上述格式编写。示例：&lt;br>
&lt;code>Given_UserIsAuthenticated_When_InvalidAccountNumberIsUsedToWithdrawMoney_Then_TransactionsWillFail&lt;/code>&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a class="link" href="https://testing.googleblog.com/" target="_blank" rel="noopener"
>在马桶上测试：测试过干吗？让他们成为DAMP！&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/unit-testing-best-practices-how-to-get-the-most-ou" target="_blank" rel="noopener"
>单元测试最佳实践：如何最大程度地利用测试自动化&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/7-popular-unit-test-naming" target="_blank" rel="noopener"
>7种流行的单元测试命名约定&lt;/a>&lt;br>
&lt;a class="link" href="http://cantgrokwontgrok.blogspot.com/2008/09/tdd-getting-started-with-test-driven.html" target="_blank" rel="noopener"
>TDD–测试驱动开发入门&lt;/a>&lt;br>
&lt;a class="link" href="https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html" target="_blank" rel="noopener"
>单元测试的命名标准&lt;/a>&lt;/p></description></item><item><title>工程目录结构</title><link>https://coderqs.github.io/2019/03/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="工程目录结构">工程目录结构&lt;/h1>
&lt;p>参考了opencv、pjproject、h323plus等开源工程的结构，并结合以往的开发习惯，整理出的这份工程目录结构。注：目前这份结构只考虑了 C/C++ 的工程&lt;/p>
&lt;div class="highlight">&lt;div style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 3
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 4
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 5
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 6
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 7
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 8
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868"> 9
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">10
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">11
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">12
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">13
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">14
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">15
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">16
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#686868">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>project_root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- 3rdparty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- builds/(platforms)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- cmake
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- include
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- src
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- module_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- module_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- readme.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- sample
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- scripts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |- doc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>readme.md&lt;/code>: 自述文件。&lt;/li>
&lt;li>&lt;code>3rdparty&lt;/code>:
第三方库的源代码。可以直接保存代码文件，也可以以子项目(&lt;code>git submodule&lt;/code>或者&lt;code>git subtree&lt;/code>)的形式存在，如果没有则不需要这文件夹。&lt;/li>
&lt;li>&lt;code>data&lt;/code>: 存放测试数据，可以没有。&lt;/li>
&lt;li>&lt;code>test&lt;/code>: 存放单元测试代码，其内部层级结构与 src 一致。&lt;/li>
&lt;li>&lt;code>sample&lt;/code>: 存放示例代码。&lt;/li>
&lt;li>&lt;code>doc&lt;/code>: 存放文档（如果有类似 wiki 的系统管理文档则可以不需要此目录，但&lt;strong>需要将链接放在&lt;code>readme.md&lt;/code>中&lt;/strong>）。&lt;/li>
&lt;li>&lt;code>builds(platforms)&lt;/code>: 构建系统，里面根据不同平台再划分一级目录，分别存放对应的构建脚本(cmake、makefile 等)。&lt;/li>
&lt;li>&lt;code>cmake&lt;/code>: 存放 &lt;code>.cmake&lt;/code> 文件，不使用 cmake 可以不要这个目录&lt;/li>
&lt;li>&lt;code>src&lt;/code>: 总源码目录，内部分模块组织。
&lt;ul>
&lt;li>每个模块放在同名的文件夹下，模块内部存放该模块的主要功能逻辑代码，但不可以出现模块嵌套的情况。&lt;/li>
&lt;li>包含内部头文件时，要从 &amp;lsquo;&amp;lsquo;project_name&amp;rsquo;&amp;rsquo; 开拼写完整路径，防止头文件名称冲突，遵循 google c++ 编码规范。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>config&lt;/code>: 存放配置文件模板。&lt;/li>
&lt;li>&lt;code>scripts&lt;/code>: 存放脚本文件，如发布脚本。&lt;/li>
&lt;li>&lt;code>include&lt;/code>: 存放所有的头文件，包括项目自身对外提供的头文件（仅针对库工程，可执行程序工程的头文件则不需要放在这里）需放在同名的文件夹下。&lt;/li>
&lt;li>&lt;code>lib&lt;/code>: 三/二方库的库文件。&lt;/li>
&lt;li>&lt;code>bin&lt;/code>: 工程的输出目录。&lt;/li>
&lt;/ul></description></item><item><title>软件版本号的风格</title><link>https://coderqs.github.io/2019/03/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0800</pubDate><guid>https://coderqs.github.io/2019/03/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E9%A3%8E%E6%A0%BC/</guid><description>&lt;h1 id="软件版本号的风格">软件版本号的风格&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>在现代软件开发过程中，相较于“重复造轮子”，开发者往往会利用一些已有的组件（如库、程序、多媒体文件）进行开发。程序开发者根据特定版本的组件来设计自己的软件。这种方式使得代码重复利用，减少了开发的工作量，降低了开发门槛。但是该软件要正确运行，必须安装了指定版本的某些组件。&lt;/p>
&lt;h3 id="依赖地狱">依赖地狱&lt;/h3>
&lt;p>操作系统中由于软件之间的依赖性不能被满足而引发的问题称为依赖地狱。依赖地狱主要有以下表现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>依赖过多&lt;/strong>：一个软件包可能依赖于众多的库，因此安装一个软件包的同时要安装几个甚至几十个库包。&lt;/li>
&lt;li>&lt;strong>多重依赖&lt;/strong>：指从所需软件包到最底层软件包之间的层级数过多。这会导致依赖性解析过于复杂，并且容易产生依赖冲突和环形依赖。&lt;/li>
&lt;li>&lt;strong>依赖冲突&lt;/strong>：即两个软件包无法共存的情况。除两个软件包包含内容直接冲突外，也可能因为其依赖的低层软件包互相冲突。因此，两个看似毫无关联的软件包也可能因为依赖性冲突而无法安装。&lt;/li>
&lt;li>&lt;strong>依赖循环&lt;/strong>：即依赖性关系形成一个闭合环路，最终导致：在安装 A 软件包之前，必须要安装 A、B、C、D 软件包，然而这是不可能的。&lt;/li>
&lt;/ul>
&lt;h2 id="版本号风格总结">版本号风格总结&lt;/h2>
&lt;h3 id="gun-风格">GUN 风格&lt;/h3>
&lt;h4 id="命名格式">命名格式&lt;/h4>
&lt;p>主版本号 . 子版本号 [. 修正版本号 build- [编译版本号 ]]&lt;br>
示例：&lt;/p>
&lt;ul>
&lt;li>1.2&lt;/li>
&lt;li>1.2.0&lt;/li>
&lt;li>1.2.0 build-1234&lt;/li>
&lt;/ul>
&lt;h4 id="规范">规范&lt;/h4>
&lt;ol>
&lt;li>项目初版本时，版本号可以是 0.1 或 0.1.0，可以是 1.0 或 1.0.0，建议主版本号从 0 开始;&lt;/li>
&lt;li>当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1;&lt;/li>
&lt;li>当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加&lt;/li>
&lt;li>修正版本号复位为 0，因而可以被忽略掉;&lt;/li>
&lt;li>当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1;&lt;/li>
&lt;li>编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制;&lt;/li>
&lt;/ol>
&lt;h3 id="windows-风格">Windows 风格&lt;/h3>
&lt;h4 id="命名格式-1">命名格式&lt;/h4>
&lt;p>主版本号 . 子版本号 [ 修正版本号 [. 编译版本号 ]]&lt;br>
示例：&lt;/p>
&lt;ul>
&lt;li>1.2.0.1234&lt;/li>
&lt;/ul>
&lt;h4 id="规范-1">规范&lt;/h4>
&lt;ol>
&lt;li>项目初版，版本号为 1.0 或 1.00;&lt;/li>
&lt;li>当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1;&lt;/li>
&lt;li>当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1;&lt;/li>
&lt;li>修正版本号复位为 0，因而可以被忽略掉;&lt;/li>
&lt;li>当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1;&lt;/li>
&lt;li>编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制;&lt;/li>
&lt;li>还可以在版本号后面加入 Alpha,Beta,Gamma,Current,RC (ReleaseCandidate),Release,Stable 等后缀，在这些后缀后面还可以加入 1 位数字的版本号;&lt;/li>
&lt;li>对于用户来说，如果某个软件的主版本号进行了升级，用户还想继续那个软件，则发行软件的公司一般要对用户收取升级费用; 而如果子版本号或修正版本号发生了升级，一般来说是免费的.&lt;/li>
&lt;/ol>
&lt;h3 id="net-framework-风格">Net Framework 风格&lt;/h3>
&lt;h4 id="命名格式-2">命名格式&lt;/h4>
&lt;p>主版本号.子版本号[.编译版本号[.修正版本号]]&lt;/p>
&lt;h4 id="规范-2">规范&lt;/h4>
&lt;ol>
&lt;li>主版本号和次版本号是必选的；内部版本号和修订号是可选的，但是&lt;strong>如果定义了修订号部分，则内部版本号就是必选的&lt;/strong>。&lt;/li>
&lt;li>所有定义的部分都必须是&lt;strong>大于或等于 0 的整数&lt;/strong>。&lt;/li>
&lt;li>应根据下面的约定使用这些部分：&lt;/li>
&lt;li>Major：具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。&lt;/li>
&lt;li>Minor：如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。&lt;/li>
&lt;li>Build：内部版本号的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。&lt;/li>
&lt;li>Revision：名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。程序集的只有内部版本号或修订号不同的后续版本被认为是先前版本的修补程序 (Hotfix) 更新。&lt;/li>
&lt;/ol>
&lt;h3 id="一些版本号中的修饰词的含义">一些版本号中的修饰词的含义&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>修饰词&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>alpha&lt;/td>
&lt;td>内部版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>beta&lt;/td>
&lt;td>测试版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>demo&lt;/td>
&lt;td>演示版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>enhance&lt;/td>
&lt;td>增强版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>free&lt;/td>
&lt;td>自由版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>full version&lt;/td>
&lt;td>完整版，即正式版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>lts&lt;/td>
&lt;td>长期维护版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>release&lt;/td>
&lt;td>发行版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rc&lt;/td>
&lt;td>即将作为正式版发布&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>standard&lt;/td>
&lt;td>标准版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ultimate&lt;/td>
&lt;td>旗舰版&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>upgrade&lt;/td>
&lt;td>升级版&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>注：严格来说上面这些并不是版本号，一般在版本号中使用的只有五个，用来表示软件处于那个开发阶段&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>base&lt;/code>: 基础架构版，此版本包含完整的功能架构，但是功能都没有做完整的实现;&lt;/li>
&lt;li>&lt;code>alpha&lt;/code>: 内部测试版，此版本表示该软件在该阶段主要是以实现功能为主,Bug 相对较多,需要继续修改,通常只在内部流通流通而不对外开放;&lt;/li>
&lt;li>&lt;code>beta&lt;/code>: 外部测试版，该版本相对 Alpha 已经有了很大的改进,不存在严重的 Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除 Bug;&lt;/li>
&lt;li>&lt;code>RC&lt;/code>: 候选版本，该版本较 beta 版更进一步了，该版本功能不再增加，和最终发布版功能一样。有点像最终发行版之前的一个预览版;&lt;/li>
&lt;li>&lt;code>release&lt;/code>: 最终发行版，是最终交付用户或者公开发布的版本，也称为标准版。需要注意的是，该版本在发布的时候回以符号 R 来代替 Release 单词;&lt;/li>
&lt;/ul>
&lt;h2 id="发布周期">发布周期&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>非紧急情况&lt;/strong>：首先由测试人员测试并提交 Bug，其次开发人员会尽量在当天修复 Bug 并在第二天发布该版本的 alpha 版，然后由测试人员测试验证关闭 Bug 之后在第三天会发布该版本的 beta 版。&lt;/li>
&lt;li>&lt;strong>紧急情况&lt;/strong>：如果 Bug 比较紧急可跳过一般流程，由开发人员尽快修复 Bug，测试确认之后直接发布该版本的 beta 版。&lt;/li>
&lt;/ul>
&lt;h2 id="带版本号的软件相关文档的命名方式">带版本号的软件相关文档的命名方式&lt;/h2>
&lt;p>项目名称 + 文件的描述 + 当前软件的版本号 + _阶段标识&lt;br>
&lt;strong>注：同一版本同一阶段的文件修改过两次以上，则在阶段标识后面加以数字标识，每次修改数字加
1。&lt;/strong>&lt;br>
示例：&lt;/p>
&lt;ul>
&lt;li>开发规范工程单元测试报告 1.2.0.bate_b(项目名称：开发规范工程，文件的描述：单元测试报告，当前版本号：1.2.0.bate，阶段标识：b) * 外包平台设计报告 1.0.0.base_b3&lt;/li>
&lt;/ul>
&lt;h3 id="阶段标识">阶段标识&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>阶段名称&lt;/th>
&lt;th>阶段标识&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>需求控制&lt;/td>
&lt;td>a&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>设计阶段&lt;/td>
&lt;td>b&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>编码阶段&lt;/td>
&lt;td>c&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>单元测试&lt;/td>
&lt;td>d&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>单元测试修改&lt;/td>
&lt;td>e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>集成测试&lt;/td>
&lt;td>f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>集成测试修改&lt;/td>
&lt;td>g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>系统测试&lt;/td>
&lt;td>h&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>系统测试修改&lt;/td>
&lt;td>i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>验收测试&lt;/td>
&lt;td>j&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>验收测试修改&lt;/td>
&lt;td>k&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a class="link" href="https://makeoptim.com/training/semver" target="_blank" rel="noopener"
>软件修养 - 版本号管理&lt;/a>&lt;br>
&lt;a class="link" href="https://developer.aliyun.com/article/379990" target="_blank" rel="noopener"
>关于版本号的总结&lt;/a>&lt;br>
&lt;a class="link" href="https://segmentfault.com/a/1190000019824358" target="_blank" rel="noopener"
>项目管理 - 版本号命名规则&lt;/a>&lt;br>
&lt;a class="link" href="https://www.jianshu.com/p/71f5a20f915c" target="_blank" rel="noopener"
>版本号管理规则&lt;/a>&lt;/p></description></item></channel></rss>